<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR Art Museum</title>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #f0f0f0;
        }
        
        #admin-auth {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            display: none;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(10px);
        }
        
        #admin-auth.active {
            display: flex;
        }
        
        .admin-auth-box {
            background: rgba(30, 30, 30, 0.95);
            padding: 40px;
            border-radius: 12px;
            max-width: 400px;
            width: 90%;
            text-align: center;
        }
        
        .admin-auth-box h2 {
            color: #667eea;
            margin-bottom: 20px;
        }
        
        .admin-auth-box input {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 6px;
            box-sizing: border-box;
            font-size: 16px;
        }
        
        .admin-auth-box button {
            width: 100%;
            padding: 12px;
            margin-top: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
        }
        
        .admin-auth-box button:hover {
            transform: translateY(-2px);
        }
        
        .admin-auth-box .error {
            color: #ff6b6b;
            margin-top: 10px;
            font-size: 14px;
        }
        
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        .airtable-config {
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }
        
        .airtable-config button {
            width: 100%;
            padding: 8px;
            margin-top: 10px;
            background: #4ade80;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .sync-status {
            margin-top: 10px;
            font-size: 0.85em;
            color: #4ade80;
        }
        
        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 12px;
            color: white;
            max-width: 320px;
            backdrop-filter: blur(10px);
            transition: transform 0.3s ease;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        #ui-overlay.hidden {
            transform: translateX(-380px);
        }
        
        #toggle-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 101;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        #toggle-ui:hover {
            background: rgba(0, 0, 0, 0.9);
        }
        
        #ui-overlay.hidden + #toggle-ui {
            left: 20px;
        }
        
        #ui-overlay:not(.hidden) + #toggle-ui {
            left: 360px;
        }
        
        h2 {
            margin-top: 0;
            font-size: 1.4em;
            color: #fff;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 10px;
        }
        
        .control-group {
            margin: 15px 0;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.9);
        }
        
        input[type="file"] {
            display: none;
        }
        
        .file-label {
            display: inline-block;
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s ease;
            font-weight: 500;
            width: 100%;
            text-align: center;
            box-sizing: border-box;
        }
        
        .file-label:hover {
            transform: translateY(-2px);
        }
        
        #drop-zone {
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin-top: 10px;
            transition: all 0.3s ease;
        }
        
        #drop-zone.dragover {
            background: rgba(102, 126, 234, 0.2);
            border-color: #667eea;
        }
        
        .instructions {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            font-size: 0.85em;
            line-height: 1.6;
        }
        
        .instructions h3 {
            margin-top: 0;
            color: #667eea;
        }
        
        #vr-button {
            margin-top: 15px;
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            font-size: 1em;
            transition: transform 0.2s ease;
        }
        
        #vr-button:hover:not(:disabled) {
            transform: translateY(-2px);
        }
        
        #vr-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #art-queue {
            margin-top: 15px;
            max-height: 120px;
            overflow-y: auto;
        }
        
        .art-item {
            display: flex;
            align-items: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            margin-bottom: 8px;
        }
        
        .art-thumb {
            width: 40px;
            height: 40px;
            object-fit: cover;
            border-radius: 4px;
            margin-right: 10px;
        }
        
        .art-info {
            flex: 1;
            font-size: 0.85em;
        }
        
        .art-status {
            font-size: 0.75em;
            color: #667eea;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #333;
            font-size: 1.2em;
            z-index: 200;
        }
        
        #placement-dialog {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 12px;
            z-index: 300;
            color: white;
            min-width: 450px;
            max-width: 600px;
            display: none;
            backdrop-filter: blur(10px);
            max-height: 90vh;
            overflow-y: auto;
        }
        
        #placement-dialog.active {
            display: block;
        }
        
        #edit-dialog {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 12px;
            z-index: 300;
            color: white;
            min-width: 450px;
            max-width: 600px;
            display: none;
            backdrop-filter: blur(10px);
            max-height: 90vh;
            overflow-y: auto;
        }
        
        #edit-dialog.active {
            display: block;
        }
        
        #placement-dialog h3, #edit-dialog h3 {
            margin-top: 0;
            color: #667eea;
        }
        
        #placement-dialog input[type="number"],
        #placement-dialog input[type="text"],
        #placement-dialog textarea,
        #edit-dialog input[type="number"],
        #edit-dialog input[type="text"],
        #edit-dialog textarea {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 4px;
            box-sizing: border-box;
        }
        
        #placement-dialog textarea,
        #edit-dialog textarea {
            min-height: 60px;
            resize: vertical;
        }
        
        #placement-dialog button,
        #edit-dialog button {
            margin-top: 15px;
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 10px;
        }
        
        #placement-dialog button:hover,
        #edit-dialog button:hover {
            transform: translateY(-2px);
        }
        
        #placement-dialog button.cancel,
        #edit-dialog button.cancel {
            background: #666;
        }
        
        .dimension-info {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            font-size: 0.85em;
        }
        
        .warning {
            color: #fbbf24;
            font-size: 0.85em;
            margin-top: 5px;
            padding: 5px;
            background: rgba(251, 191, 36, 0.1);
            border-radius: 4px;
        }
        
        .spots-indicator {
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            font-size: 0.85em;
        }
        
        .spot-available {
            color: #4ade80;
        }
        
        .spot-occupied {
            color: #f87171;
        }
        
        .supported-formats {
            font-size: 0.75em;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 5px;
        }
        
        .location-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 10px 0;
        }
        
        .location-option {
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }
        
        .location-option:hover:not(.occupied) {
            background: rgba(102, 126, 234, 0.2);
            border-color: #667eea;
        }
        
        .location-option.selected {
            background: rgba(102, 126, 234, 0.3);
            border-color: #667eea;
        }
        
        .location-option.occupied {
            opacity: 0.5;
            cursor: not-allowed;
            background: rgba(248, 113, 113, 0.1);
        }
        
        .location-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .location-status {
            font-size: 0.8em;
            color: #4ade80;
        }
        
        .location-option.occupied .location-status {
            color: #f87171;
        }
        
        .section-divider {
            margin: 20px 0;
            padding: 10px 0;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .optional-label {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.8em;
            font-style: italic;
        }
        
        #art-viewer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 500;
            display: none;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(10px);
        }
        
        #art-viewer.active {
            display: flex;
        }
        
        #viewer-content {
            position: relative;
            max-width: 90%;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-y: auto;
            padding: 20px;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
        }
        
        #viewer-content::-webkit-scrollbar {
            width: 8px;
        }
        
        #viewer-content::-webkit-scrollbar-track {
            background: transparent;
        }
        
        #viewer-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }
        
        #viewer-content::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }
        
        #viewer-image {
            max-width: 100%;
            max-height: 50vh;
            object-fit: contain;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            margin-bottom: 20px;
        }
        
        #viewer-info {
            color: white;
            text-align: center;
            max-width: 800px;
            width: 100%;
            padding: 0 20px 100px 20px;
        }
        
        #viewer-title {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 15px;
            line-height: 1.3;
        }
        
        #viewer-artist {
            font-size: 1.4em;
            color: #aaa;
            margin-bottom: 20px;
        }
        
        #viewer-description {
            font-size: 1.1em;
            color: #e0e0e0;
            line-height: 1.8;
            text-align: left;
            max-height: none;
            overflow-y: visible;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-top: 10px;
        }
        
        #viewer-close {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s;
            z-index: 501;
        }
        
        #viewer-close:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }
        
        .zoom-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 501;
        }
        
        .zoom-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s;
        }
        
        .zoom-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div id="admin-auth">
        <div class="admin-auth-box">
            <h2>Admin Access</h2>
            <p style="color: rgba(255,255,255,0.7); margin-bottom: 20px;">Enter admin password to access artwork management</p>
            <input type="password" id="admin-password" placeholder="Password">
            <button onclick="checkAdminPassword()">Login</button>
            <button onclick="closeAdminAuth()" style="background: #666; margin-top: 10px;">Cancel</button>
            <div id="auth-error" class="error"></div>
        </div>
    </div>
    
    <div id="loading">Loading museum...</div>
    <div id="canvas-container"></div>
    
    <div id="ui-overlay">
        <h2>VR Art Museum</h2>
        
        <div id="admin-section" style="display: none;">
            <div class="airtable-config">
                <h3 style="margin-top: 0; color: #667eea; font-size: 1em;">Gallery Sync</h3>
                <button onclick="saveAirtableConfig()">Reload Artworks from Gallery</button>
                <div id="sync-status" class="sync-status"></div>
            </div>
            
            <div class="control-group">
                <label>Add Artwork by URL</label>
                <input type="text" id="image-url-input" placeholder="https://example.com/image.jpg" 
                       style="width: 100%; padding: 10px; border: 1px solid rgba(255,255,255,0.3); background: rgba(255,255,255,0.1); color: white; border-radius: 6px; box-sizing: border-box; margin: 10px 0;">
                <button onclick="loadArtworkFromURL()" style="width: 100%; padding: 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500;">
                    Load Artwork
                </button>
                <div class="supported-formats">
                    Enter a direct link to an image (JPG, PNG, GIF, etc.)<br>
                    Note: Some CDN images may have loading restrictions
                </div>
            </div>
            
            <div class="spots-indicator">
                <div>Available Wall Spots: <span id="wall-spots" class="spot-available">0/0</span></div>
            </div>
            
            <div id="art-queue"></div>
        </div>
        
        <div id="public-section">
            <div class="instructions">
                <h3>Welcome to the Gallery</h3>
                Click on any artwork to view details and zoom in.<br><br>
                Admins can add artwork by entering image URLs.
            </div>
        </div>
        
        <button id="vr-button" disabled>Enter VR Mode</button>
        
        <div class="instructions">
            <h3>Controls:</h3>
            <strong>Desktop:</strong><br>
            WASD or Arrow Keys to move<br>
            Mouse to look around<br>
            Click artwork to view details<br>
            R to remove artwork (admin)<br>
            Tab to toggle spot view<br>
            <br>
            <strong>VR Mode:</strong><br>
            Use controllers to point and interact<br>
            Trigger to select<br>
            Thumbstick to move
        </div>
    </div>
    
    <button id="toggle-ui">Menu</button>
    
            <div id="placement-dialog">
        <h3>Artwork Details</h3>
        <div id="artwork-name" style="margin-bottom: 15px; color: #667eea;"></div>
        
        <div id="image-preview" style="display:none; margin-bottom: 15px;">
            <img id="preview-img" style="max-width: 100%; max-height: 150px; border-radius: 6px;">
        </div>
        
        <div class="section-divider">
            <label><strong>Title:</strong> <span class="optional-label">(required)</span></label>
            <input type="text" id="title-input" placeholder="Enter artwork title">
            
            <label style="margin-top: 15px;"><strong>Artist:</strong> <span class="optional-label">(required)</span></label>
            <input type="text" id="artist-input" placeholder="Enter artist name">
            
            <label style="margin-top: 15px;"><strong>Description:</strong> <span class="optional-label">(optional)</span></label>
            <textarea id="description-input" placeholder="Add a description..."></textarea>
        </div>
        
        <div class="section-divider">
            <label>Select Location:</label>
            <div id="location-grid" class="location-grid"></div>
        </div>
        
        <div class="section-divider">
            <label id="dimension-label">Height (inches):</label>
            <input type="number" id="height-input" value="36" min="6" max="144" step="6">
            <div class="dimension-info" id="size-preview"></div>
        </div>
        
        <div id="size-warning" class="warning" style="display:none;"></div>
        
        <div>
            <button onclick="placeArtwork()">Place Artwork</button>
            <button class="cancel" onclick="cancelPlacement()">Cancel</button>
        </div>
    </div>
    
    <div id="edit-dialog">
        <h3>Edit Artwork</h3>
        <div id="edit-artwork-name" style="margin-bottom: 15px;"></div>
        
        <div id="edit-image-preview" style="display:none; margin-bottom: 15px;">
            <img id="edit-preview-img" style="max-width: 100%; max-height: 150px; border-radius: 6px;">
        </div>
        
        <div class="section-divider">
            <label>Title:</label>
            <input type="text" id="edit-title-input" placeholder="Untitled">
            
            <label>Artist:</label>
            <input type="text" id="edit-artist-input" placeholder="Unknown Artist">
            
            <label>Description:</label>
            <textarea id="edit-description-input" placeholder="Add a description..."></textarea>
        </div>
        
        <div class="section-divider">
            <label>Height (inches):</label>
            <input type="number" id="edit-height-input" value="36" min="6" max="144" step="6">
        </div>
        
        <div>
            <button onclick="saveArtworkEdit()">Save Changes</button>
            <button class="cancel" onclick="cancelEdit()">Cancel</button>
        </div>
    </div>
    
    <div id="art-viewer">
        <button id="viewer-close">×</button>
        <div id="viewer-content">
            <img id="viewer-image" src="">
            <div id="viewer-info">
                <div id="viewer-title"></div>
                <div id="viewer-artist"></div>
                <div id="viewer-description"></div>
            </div>
            <div class="zoom-controls">
                <button class="zoom-btn" onclick="zoomIn()">+</button>
                <button class="zoom-btn" onclick="zoomOut()">−</button>
                <button class="zoom-btn" onclick="resetZoom()">⟲</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let isAdmin = false;
        let escapeCount = 0;
        let escapeTimer = null;
        const ADMIN_PASSWORD = 'password';
        
        const WEBHOOK_URL = 'https://n8n.intelechia.com/webhook/gallery';
        const CREATE_WEBHOOK_URL = 'https://n8n.intelechia.com/webhook/create-gallery';
        const EDIT_WEBHOOK_URL = 'https://n8n.intelechia.com/webhook/edit-gallery';

        const LOCATION_NAME_TO_ID_MAP = {
            'Back Left Wall': 'back-1',
            'Back Center Wall': 'back-2',
            'Back Right Wall': 'back-3',
            'Left Front': 'left-1',
            'Left Back': 'left-2',
            'Right Front': 'right-1',
            'Right Back': 'right-2',
            'Front Left': 'floor-1',
            'Front Center': 'floor-2',
            'Front Right': 'floor-3',
            'Rear Left': 'floor-4',
            'Rear Right': 'floor-5',
            'Center Stage': 'floor-center'
        };

        const LOCATION_ID_TO_NAME_MAP = Object.keys(LOCATION_NAME_TO_ID_MAP).reduce((acc, name) => {
            const id = LOCATION_NAME_TO_ID_MAP[name];
            acc[id] = name;
            return acc;
        }, {});
        
        let scene, camera, renderer;
        let museum, artworks = [];
        let raycaster, mouse;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let vrSession = null;
        let artQueue = [];
        let wallSpots = [];
        let floorSpots = [];
        let currentPendingArt = null;
        let viewMode = 'normal';
        let placards = [];
        let selectedLocation = null;
        let currentZoom = 1;
        let currentEditingArtwork = null;
        
        function checkAdminPassword() {
            const password = document.getElementById('admin-password').value;
            const errorDiv = document.getElementById('auth-error');
            
            if (password === ADMIN_PASSWORD) {
                isAdmin = true;
                closeAdminAuth();
                showAdminView();
                errorDiv.textContent = '';
            } else {
                errorDiv.textContent = 'Incorrect password';
            }
        }
        
        function closeAdminAuth() {
            document.getElementById('admin-auth').classList.remove('active');
            document.getElementById('admin-password').value = '';
        }
        
        function showAdminView() {
            console.log('=== ADMIN MODE ACTIVATED ===');
            isAdmin = true;
            console.log('isAdmin set to:', isAdmin);
            
            document.getElementById('admin-section').style.display = 'block';
            document.getElementById('public-section').style.display = 'none';
            loadArtworksFromAirtable();
        }
        
        async function loadArtworksFromAirtable() {
            try {
                const response = await fetch(WEBHOOK_URL);
                if (!response.ok) {
                    throw new Error(`Failed to fetch artworks: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Loaded data from webhook:', data);
                
                // Filter for ONLY artwork records (have Title, Artist, Type, and Art fields)
                const artworkRecords = data.filter(record => 
                    record.Title && 
                    record.Artist && 
                    record.Type && 
                    record.Art && 
                    record.Art.length > 0 &&
                    !record['Location ID'] && // Exclude location records
                    !record['Exhibition ID'] // Exclude exhibition records
                );
                
                console.log('Filtered artwork records:', artworkRecords);
                
                for (const record of artworkRecords) {
                    // Skip if not currently placed
                    if (!record['Currently Placed']) {
                        console.log(`Skipping ${record.Title} - not currently placed`);
                        continue;
                    }
                    
                    // Get art file from Art field (array of attachments)
                    const artFile = record.Art[0]; // Get first attachment
                    
                    if (!artFile || !artFile.url) {
                        console.warn(`No art file for ${record.Title}`);
                        continue;
                    }
                    
                    const metadata = {
                        title: record.Title || '',
                        artist: record.Artist || '',
                        description: record.Description || ''
                    };
                    
                    // Get location name from Location Name field (it's an array)
                    const locationName = record['Location Name'] && record['Location Name'].length > 0 
                        ? record['Location Name'][0] 
                        : null;
                    
                    console.log(`Processing ${record.Title}, Location Name:`, locationName);
                    
                    const locationId = mapLocationNameToId(locationName);
                    
                    if (!locationId) {
                        console.warn(`Could not map location for ${record.Title}:`, locationName);
                        continue;
                    }
                    
                    // Convert height from inches to meters
                    const heightInches = record['Height (inches)'] || 36;
                    const heightMeters = heightInches * 0.0254;
                    
                    console.log(`Loading ${record.Title} at ${locationId}, height: ${heightInches}" (${heightMeters}m)`);
                    
                    if (record.Type === 'Image') {
                        await loadImageFromURL(artFile.url, locationId, heightMeters, metadata, record.id);
                    }
                }
                
                updateSpotCounters();
                document.getElementById('sync-status').textContent = `✓ Loaded ${artworkRecords.length} artworks`;
                document.getElementById('sync-status').style.color = '#4ade80';
            } catch (error) {
                console.error('Failed to load artworks:', error);
                document.getElementById('sync-status').textContent = '❌ Failed to load artworks';
                document.getElementById('sync-status').style.color = '#ff6b6b';
            }
        }
        
        async function loadImageFromURL(url, locationId, height, metadata, airtableId) {
            const wallSpot = wallSpots.find(s => s.userData.id === locationId);
            if (!wallSpot || wallSpot.userData.occupied) return;
            
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    const aspectRatio = img.width / img.height;
                    const textureLoader = new THREE.TextureLoader();
                    textureLoader.setCrossOrigin('anonymous');
                    textureLoader.load(url, (texture) => {
                        const width = height * aspectRatio;
                        createArtworkMesh(texture, metadata.title || 'Untitled', wallSpot, 
                            { width, height }, metadata, url, airtableId);
                        resolve();
                    });
                };
                img.src = url;
            });
        }
        
        function generateArtworkId(title) {
            const base = (title || 'artwork').toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
            const slug = base || 'artwork';
            const randomSegment = Math.random().toString(36).substring(2, 8).toUpperCase();
            return `${slug}-${randomSegment}`;
        }

        function sanitizeFileName(name) {
            const base = (name || 'artwork').toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
            return base || 'artwork';
        }

        function roundToTwoDecimals(value) {
            if (typeof value !== 'number' || !isFinite(value)) {
                return undefined;
            }
            return Math.round(value * 100) / 100;
        }

        async function createArtworkInAirtable(artworkData) {
            console.log('=== CREATE ARTWORK IN AIRTABLE ===');
            console.log('Is Admin?:', isAdmin);
            console.log('Artwork Data:', artworkData);

            if (!isAdmin) {
                console.log('Not admin, skipping Airtable save');
                return null;
            }

            const heightFeet = typeof artworkData.heightFeet === 'number' ? artworkData.heightFeet : undefined;
            const heightInches = heightFeet !== undefined ? heightFeet * 12 : undefined;
            const aspectRatio = typeof artworkData.aspectRatio === 'number' && artworkData.aspectRatio > 0
                ? artworkData.aspectRatio
                : null;
            const widthInches = aspectRatio && heightInches !== undefined ? heightInches * aspectRatio : null;

            let fileExtension = '';
            if (artworkData.imageUrl) {
                const urlWithoutQuery = artworkData.imageUrl.split('?')[0];
                const extensionMatch = urlWithoutQuery.match(/\.([a-z0-9]+)$/i);
                fileExtension = extensionMatch ? extensionMatch[1].toLowerCase() : '';
            }

            const normalizedExtension = fileExtension || 'jpg';
            const fileFormat = artworkData.imageUrl ? normalizedExtension.toUpperCase() : '';
            const attachmentFileName = `${sanitizeFileName(artworkData.originalFileName || artworkData.title)}.${normalizedExtension}`;
            const attachments = artworkData.imageUrl ? [{
                url: artworkData.imageUrl,
                filename: attachmentFileName
            }] : [];

            const payload = {
                Title: artworkData.title || 'Untitled',
                'Artwork ID': artworkData.artworkId || generateArtworkId(artworkData.title),
                Artist: artworkData.artist || '',
                Description: artworkData.description || '',
                Type: artworkData.type,
                Art: attachments,
                'File Format': fileFormat,
                'Date Added': new Date().toISOString(),
                'Currently Placed': true,
                Location: artworkData.locationId ? [artworkData.locationId] : [],
                'Location Name': artworkData.locationName ? [artworkData.locationName] : [],
                Tags: Array.isArray(artworkData.tags) ? artworkData.tags : [],
                Notes: artworkData.notes || ''
            };

            if (heightFeet !== undefined) {
                const roundedHeightFeet = roundToTwoDecimals(heightFeet);
                if (roundedHeightFeet !== undefined) {
                    payload['Height (feet)'] = roundedHeightFeet;
                }
            }

            if (heightInches !== undefined) {
                const roundedHeightInches = roundToTwoDecimals(heightInches);
                if (roundedHeightInches !== undefined) {
                    payload['Height (inches)'] = roundedHeightInches;
                }
            }

            const roundedWidthInches = widthInches !== null ? roundToTwoDecimals(widthInches) : undefined;
            if (roundedWidthInches !== undefined) {
                payload['Width (inches)'] = roundedWidthInches;
            }

            console.log('Sending to webhook:', CREATE_WEBHOOK_URL);
            console.log('Payload:', payload);
            
            try {
                const response = await fetch(CREATE_WEBHOOK_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });
                
                console.log('Response status:', response.status);
                console.log('Response OK?:', response.ok);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Error response:', errorText);
                    throw new Error(`Failed to create artwork: ${response.status} - ${errorText}`);
                }
                
                const result = await response.json();
                console.log('Artwork created in Airtable:', result);
                return result.id || null;
            } catch (error) {
                console.error('Failed to create artwork in Airtable:', error);
                return null;
            }
        }
        
        async function updateArtworkInAirtable(artworkData) {
            if (!isAdmin) return null;

            try {
                const payload = {
                    id: artworkData.id,
                    Title: artworkData.title,
                    Artist: artworkData.artist,
                    Description: artworkData.description,
                    'Currently Placed': artworkData.currentlyPlaced !== undefined ? artworkData.currentlyPlaced : true
                };

                if (artworkData.heightFeet !== undefined) {
                    const roundedFeet = roundToTwoDecimals(artworkData.heightFeet);
                    if (roundedFeet !== undefined) {
                        payload['Height (feet)'] = roundedFeet;
                    }

                    const roundedInches = roundToTwoDecimals(artworkData.heightFeet * 12);
                    if (roundedInches !== undefined) {
                        payload['Height (inches)'] = roundedInches;
                    }
                }

                if (artworkData.location) {
                    payload.Location = [artworkData.location];
                }

                if (artworkData.locationName) {
                    payload['Location Name'] = [artworkData.locationName];
                }

                const response = await fetch(EDIT_WEBHOOK_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to update artwork: ${response.status}`);
                }
                
                return await response.json();
            } catch (error) {
                console.error('Failed to update artwork:', error);
                return null;
            }
        }
        
        async function deleteArtworkFromAirtable(airtableId) {
            if (!isAdmin || !airtableId) return;
            
            try {
                await updateArtworkInAirtable({
                    id: airtableId,
                    currentlyPlaced: false
                });
            } catch (error) {
                console.error('Failed to delete from Airtable:', error);
            }
        }
        
        function saveAirtableConfig() {
            document.getElementById('sync-status').textContent = '⏳ Loading artworks from webhook...';
            document.getElementById('sync-status').style.color = '#667eea';
            loadArtworksFromAirtable();
        }
        
        const WALL_POSITIONS = [
            { id: 'back-1', position: new THREE.Vector3(-3.5, 2.5, -9.9), wall: 'back', rotation: 0, maxWidth: 5, wallLength: 16 * 0.3048, displayName: 'back-1' },
            { id: 'back-2', position: new THREE.Vector3(0, 2.5, -9.9), wall: 'back', rotation: 0, maxWidth: 16 * 0.3048, wallLength: 16 * 0.3048, displayName: 'back-2' },
            { id: 'back-3', position: new THREE.Vector3(3.5, 2.5, -9.9), wall: 'back', rotation: 0, maxWidth: 5, wallLength: 16 * 0.3048, displayName: 'back-3' },
            { id: 'left-1', position: new THREE.Vector3(-7.9, 2.5, -3), wall: 'left', rotation: Math.PI / 2, maxWidth: 10 * 0.3048, wallLength: 20 * 0.3048, displayName: 'left-1' },
            { id: 'left-2', position: new THREE.Vector3(-7.9, 2.5, 3), wall: 'left', rotation: Math.PI / 2, maxWidth: 10 * 0.3048, wallLength: 20 * 0.3048, displayName: 'left-2' },
            { id: 'right-1', position: new THREE.Vector3(7.9, 2.5, -3), wall: 'right', rotation: -Math.PI / 2, maxWidth: 10 * 0.3048, wallLength: 20 * 0.3048, displayName: 'right-1' },
            { id: 'right-2', position: new THREE.Vector3(7.9, 2.5, 3), wall: 'right', rotation: -Math.PI / 2, maxWidth: 10 * 0.3048, wallLength: 20 * 0.3048, displayName: 'right-2' },
        ];
        
        const FLOOR_POSITIONS = [
            { id: 'floor-1', position: new THREE.Vector3(-4, 0, -3), type: 'pedestal', displayName: 'Front Left' },
            { id: 'floor-2', position: new THREE.Vector3(0, 0, -3), type: 'pedestal', displayName: 'Front Center' },
            { id: 'floor-3', position: new THREE.Vector3(4, 0, -3), type: 'pedestal', displayName: 'Front Right' },
            { id: 'floor-4', position: new THREE.Vector3(-4, 0, 3), type: 'pedestal', displayName: 'Rear Left' },
            { id: 'floor-5', position: new THREE.Vector3(4, 0, 3), type: 'pedestal', displayName: 'Rear Right' },
            { id: 'floor-center', position: new THREE.Vector3(0, 0, 0), type: 'large', displayName: 'Center Stage' },
        ];
        
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            scene.fog = new THREE.Fog(0xf0f0f0, 10, 25);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 7);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.xr.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            createMuseum();
            createPlacementSpots();
            setupLighting();
            setupControls();
            setupEventListeners();
            checkVRSupport();
            updateSpotCounters();
            
            document.getElementById('loading').style.display = 'none';
            
            loadArtworksFromAirtable();
            
            animate();
        }
        
        function createMuseum() {
            museum = new THREE.Group();
            
            const roomWidth = 16;
            const roomDepth = 20;
            
            const floorGeometry = new THREE.PlaneGeometry(roomWidth, roomDepth);
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0xfafafa, roughness: 0.3, metalness: 0.1 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            museum.add(floor);
            
            const ceilingGeometry = new THREE.PlaneGeometry(roomWidth, roomDepth);
            const ceilingMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.95, metalness: 0 });
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = 5;
            museum.add(ceiling);
            
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xf5f5f5, roughness: 0.9, metalness: 0.1 });
            
            const backWall = new THREE.Mesh(new THREE.PlaneGeometry(roomWidth, 5), wallMaterial);
            backWall.position.z = -10;
            backWall.position.y = 2.5;
            backWall.receiveShadow = true;
            backWall.name = 'wall';
            museum.add(backWall);
            
            const doorWidth = 3;
            const sideWidth = (roomWidth - doorWidth) / 2;
            
            const frontWallLeft = new THREE.Mesh(new THREE.PlaneGeometry(sideWidth, 5), wallMaterial);
            frontWallLeft.position.set(-(sideWidth/2 + doorWidth/2), 2.5, 10);
            frontWallLeft.rotation.y = Math.PI;
            frontWallLeft.name = 'wall';
            museum.add(frontWallLeft);
            
            const frontWallRight = new THREE.Mesh(new THREE.PlaneGeometry(sideWidth, 5), wallMaterial);
            frontWallRight.position.set(sideWidth/2 + doorWidth/2, 2.5, 10);
            frontWallRight.rotation.y = Math.PI;
            frontWallRight.name = 'wall';
            museum.add(frontWallRight);
            
            const doorTop = new THREE.Mesh(new THREE.PlaneGeometry(doorWidth, 2.5), wallMaterial);
            doorTop.position.set(0, 3.75, 10);
            doorTop.rotation.y = Math.PI;
            museum.add(doorTop);
            
            const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(roomDepth, 5), wallMaterial);
            leftWall.position.set(-8, 2.5, 0);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.receiveShadow = true;
            leftWall.name = 'wall';
            museum.add(leftWall);
            
            const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(roomDepth, 5), wallMaterial);
            rightWall.position.set(8, 2.5, 0);
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.receiveShadow = true;
            rightWall.name = 'wall';
            museum.add(rightWall);
            
            const textureLoader = new THREE.TextureLoader();
            const woodTexture = textureLoader.load('https://t3.ftcdn.net/jpg/04/18/99/38/360_F_418993894_rtkXtiukgI1V6Rh4UQksKDNgQWc4TF2B.jpg');
            woodTexture.wrapS = THREE.RepeatWrapping;
            woodTexture.wrapT = THREE.RepeatWrapping;
            woodTexture.repeat.set(2, 1);
            
            const benchGeometry = new THREE.BoxGeometry(2.5, 0.5, 0.8);
            const benchMaterial = new THREE.MeshStandardMaterial({ map: woodTexture, roughness: 0.6, metalness: 0.1 });
            const bench = new THREE.Mesh(benchGeometry, benchMaterial);
            bench.position.set(0, 0.25, 6);
            bench.castShadow = true;
            museum.add(bench);
            
            scene.add(museum);
        }
        
        function createPlacementSpots() {
            WALL_POSITIONS.forEach(spot => {
                const spotMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 2, 0.05),
                    new THREE.MeshStandardMaterial({
                        color: 0x667eea,
                        emissive: 0x667eea,
                        emissiveIntensity: 0.2,
                        transparent: true,
                        opacity: 0.3
                    })
                );
                spotMesh.position.copy(spot.position);
                spotMesh.rotation.y = spot.rotation;
                spotMesh.name = 'wall-spot';
                spotMesh.userData = { ...spot, occupied: false, currentWidth: 0 };
                spotMesh.visible = false;
                wallSpots.push(spotMesh);
                scene.add(spotMesh);
            });
            
            FLOOR_POSITIONS.forEach(spot => {
                const spotMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(spot.type === 'large' ? 2 : 1.2, 0.1, spot.type === 'large' ? 2 : 1.2),
                    new THREE.MeshStandardMaterial({
                        color: 0x667eea,
                        emissive: 0x667eea,
                        emissiveIntensity: 0.3,
                        transparent: true,
                        opacity: 0.5
                    })
                );
                spotMesh.position.copy(spot.position);
                spotMesh.position.y = 0.01;
                spotMesh.name = 'floor-spot';
                spotMesh.userData = { ...spot, occupied: false, pedestal: null };
                spotMesh.visible = false;
                floorSpots.push(spotMesh);
                scene.add(spotMesh);
            });
        }
        
        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.65);
            scene.add(ambientLight);
            
            const generalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            generalLight.position.set(0, 4, 2);
            generalLight.castShadow = true;
            generalLight.shadow.mapSize.width = 2048;
            generalLight.shadow.mapSize.height = 2048;
            generalLight.shadow.camera.left = -10;
            generalLight.shadow.camera.right = 10;
            generalLight.shadow.camera.top = 10;
            generalLight.shadow.camera.bottom = -10;
            scene.add(generalLight);
            
            const trackMaterial = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, metalness: 0.9, roughness: 0.1 });
            const trackHeight = 4.95;
            const trackOffset = 1.2;
            
            const backTrack = new THREE.Mesh(new THREE.BoxGeometry(14, 0.03, 0.08), trackMaterial);
            backTrack.position.set(0, trackHeight, -10 + trackOffset);
            museum.add(backTrack);
            
            const sideTrackGeometry = new THREE.BoxGeometry(0.08, 0.03, 16);
            const leftTrack = new THREE.Mesh(sideTrackGeometry, trackMaterial);
            leftTrack.position.set(-8 + trackOffset, trackHeight, 0);
            museum.add(leftTrack);
            
            const rightTrack = new THREE.Mesh(sideTrackGeometry, trackMaterial);
            rightTrack.position.set(8 - trackOffset, trackHeight, 0);
            museum.add(rightTrack);
            
            const createTrackLight = (x, z, targetX, targetZ, targetY = 2.5) => {
                const fixtureGeometry = new THREE.CylinderGeometry(0.05, 0.06, 0.15, 6);
                const fixture = new THREE.Mesh(fixtureGeometry, trackMaterial);
                fixture.position.set(x, trackHeight - 0.08, z);
                fixture.lookAt(targetX, targetY, targetZ);
                fixture.rotateX(Math.PI / 2);
                museum.add(fixture);
                
                const spotLight = new THREE.SpotLight(0xffffff, 0.5);
                spotLight.position.set(x, trackHeight - 0.1, z);
                spotLight.target.position.set(targetX, targetY, targetZ);
                spotLight.angle = Math.PI / 8;
                spotLight.penumbra = 0.5;
                spotLight.distance = 8;
                spotLight.decay = 2;
                spotLight.castShadow = true;
                spotLight.shadow.mapSize.width = 1024;
                spotLight.shadow.mapSize.height = 1024;
                spotLight.shadow.camera.near = 0.5;
                spotLight.shadow.camera.far = 10;
                
                scene.add(spotLight);
                scene.add(spotLight.target);
                
                return spotLight;
            };
            
            WALL_POSITIONS.forEach(spot => {
                const offsetDir = new THREE.Vector3(0, 0, trackOffset);
                offsetDir.applyEuler(new THREE.Euler(0, spot.rotation, 0));
                createTrackLight(
                    spot.position.x + offsetDir.x,
                    spot.position.z + offsetDir.z,
                    spot.position.x,
                    spot.position.z,
                    spot.position.y
                );
            });
            
            FLOOR_POSITIONS.forEach(spot => {
                const spotLight = new THREE.SpotLight(0xffffff, 0.3);
                spotLight.position.set(spot.position.x, 3.5, spot.position.z);
                spotLight.target.position.copy(spot.position);
                spotLight.angle = Math.PI / 6;
                spotLight.penumbra = 0.6;
                spotLight.distance = 5;
                scene.add(spotLight);
                scene.add(spotLight.target);
            });
        }
        
        function createPedestal(position, type) {
            const pedestalGeometry = type === 'large' ? 
                new THREE.CylinderGeometry(1, 1, 0.8, 32) :
                new THREE.CylinderGeometry(0.6, 0.6, 0.8, 32);
                
            const pedestal = new THREE.Mesh(
                pedestalGeometry,
                new THREE.MeshStandardMaterial({ color: 0xe0e0e0, roughness: 0.3, metalness: 0.2 })
            );
            pedestal.position.copy(position);
            pedestal.position.y = 0.4;
            pedestal.castShadow = true;
            pedestal.receiveShadow = true;
            scene.add(pedestal);
            
            return pedestal;
        }
        
        function createPlacard(metadata, position, rotation, isFloor = false, artworkWidth = 0, artworkHeight = 0) {
            if (!metadata.title && !metadata.artist && !metadata.description) {
                return null;
            }
            
            const placardGroup = new THREE.Group();
            
            const placardGeometry = new THREE.BoxGeometry(0.4, 0.25, 0.02);
            const placardMaterial = new THREE.MeshStandardMaterial({ color: 0xf0f0f0, roughness: 0.8, metalness: 0.1 });
            const placard = new THREE.Mesh(placardGeometry, placardMaterial);
            placardGroup.add(placard);
            
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 160;
            const context = canvas.getContext('2d');
            
            context.fillStyle = '#f0f0f0';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.fillStyle = '#2a2a2a';
            context.font = 'bold 20px Arial';
            context.fillText(metadata.title || '', 10, 30);
            
            if (metadata.artist) {
                context.font = '16px Arial';
                context.fillText(metadata.artist, 10, 55);
            }
            
            if (metadata.description) {
                context.font = '12px Arial';
                const words = metadata.description.split(' ');
                let line = '';
                let y = 85;
                
                for (let word of words) {
                    const testLine = line + word + ' ';
                    const metrics = context.measureText(testLine);
                    if (metrics.width > 236 && line !== '') {
                        context.fillText(line, 10, y);
                        line = word + ' ';
                        y += 15;
                        if (y > 150) break;
                    } else {
                        line = testLine;
                    }
                }
                if (y <= 150) context.fillText(line, 10, y);
            }
            
            const textTexture = new THREE.CanvasTexture(canvas);
            const textMaterial = new THREE.MeshBasicMaterial({ map: textTexture });
            const textMesh = new THREE.Mesh(new THREE.PlaneGeometry(0.38, 0.23), textMaterial);
            textMesh.position.z = 0.011;
            placardGroup.add(textMesh);
            
            placardGroup.position.copy(position);
            placardGroup.rotation.y = rotation;
            
            if (isFloor) {
                placardGroup.position.y = 0.9;
            } else {
                const halfArtworkHeight = artworkHeight / 2;
                const placardHeight = 0.25;
                const safeGap = 0.3;
                
                const verticalOffset = -(halfArtworkHeight + placardHeight/2 + safeGap);
                
                let horizontalOffset = 0;
                if (artworkHeight > 3) {
                    horizontalOffset = (artworkWidth / 2) + 0.3;
                }
                
                const offset = new THREE.Vector3(horizontalOffset, verticalOffset, 0.05);
                offset.applyEuler(new THREE.Euler(0, rotation, 0));
                placardGroup.position.add(offset);
            }
            
            placards.push(placardGroup);
            scene.add(placardGroup);
            
            return placardGroup;
        }
        
        function setupControls() {
            renderer.domElement.addEventListener('click', () => {
                renderer.domElement.requestPointerLock();
            });
            
            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === renderer.domElement) {
                    document.addEventListener('mousemove', onMouseMove);
                } else {
                    document.removeEventListener('mousemove', onMouseMove);
                }
            });
        }
        
        let pitch = 0;
        let yaw = 0;
        
        function onMouseMove(event) {
            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;
            
            yaw -= movementX * 0.002;
            pitch -= movementY * 0.002;
            pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
            
            camera.rotation.set(pitch, yaw, 0, 'YXZ');
        }
        
        function loadArtworkFromURL() {
            const url = document.getElementById('image-url-input').value.trim();
            
            if (!url) {
                alert('Please enter an image URL');
                return;
            }
            
            // Validate URL format
            try {
                new URL(url);
            } catch (e) {
                alert('Please enter a valid URL');
                return;
            }
            
            console.log('Preparing to add artwork from URL:', url);
            
            // Show placement dialog immediately with metadata fields
            // We'll try to load the image in the background to get aspect ratio
            showPlacementDialogWithURL(url);
        }
        
        function showPlacementDialogWithURL(imageUrl) {
            const dialog = document.getElementById('placement-dialog');
            const fileName = imageUrl.split('/').pop() || 'Untitled';
            
            document.getElementById('artwork-name').textContent = `Add New Artwork`;
            
            // Show image preview
            const imagePreview = document.getElementById('image-preview');
            document.getElementById('preview-img').src = imageUrl;
            imagePreview.style.display = 'block';
            
            // Store the URL temporarily
            currentPendingArt = { 
                imageUrl: imageUrl,
                type: 'image',
                aspectRatio: null // Will try to determine when placing
            };
            
            document.getElementById('dimension-label').textContent = 'Height (inches):';
            
            // Set up location grid
            const locationGrid = document.getElementById('location-grid');
            locationGrid.innerHTML = '';
            selectedLocation = null;
            
            const positions = WALL_POSITIONS;
            const spots = wallSpots;
            
            positions.forEach(pos => {
                const spot = spots.find(s => s.userData.id === pos.id);
                const locationOption = document.createElement('div');
                locationOption.className = 'location-option';
                locationOption.dataset.id = pos.id;
                
                if (spot && spot.userData.occupied) {
                    locationOption.classList.add('occupied');
                }
                
                locationOption.innerHTML = `
                    <div class="location-name">${pos.displayName}</div>
                    <div class="location-status">${spot && spot.userData.occupied ? 'Occupied' : 'Available'}</div>
                `;
                
                if (!spot || !spot.userData.occupied) {
                    locationOption.addEventListener('click', () => {
                        document.querySelectorAll('.location-option').forEach(opt => 
                            opt.classList.remove('selected'));
                        locationOption.classList.add('selected');
                        selectedLocation = pos.id;
                        updateSizePreview();
                    });
                }
                
                locationGrid.appendChild(locationOption);
            });
            
            const firstAvailable = positions.find(p => 
                !spots.find(s => s.userData.id === p.id).userData.occupied);
            if (firstAvailable) {
                selectedLocation = firstAvailable.id;
                locationGrid.querySelector(`[data-id="${firstAvailable.id}"]`).classList.add('selected');
            }
            
            // Clear and focus on metadata fields
            document.getElementById('title-input').value = '';
            document.getElementById('artist-input').value = '';
            document.getElementById('description-input').value = '';
            
            // Try to load image in background to get aspect ratio
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
                const aspectRatio = img.width / img.height;
                if (currentPendingArt && currentPendingArt.imageUrl === imageUrl) {
                    currentPendingArt.aspectRatio = aspectRatio;
                    console.log('Image loaded successfully. Aspect ratio:', aspectRatio);
                    updateSizePreview();
                }
            };
            img.onerror = () => {
                console.warn('Could not load image for preview, but will still attempt to use it. This may be due to CORS restrictions.');
                // Set a default aspect ratio if we can't load the image
                if (currentPendingArt && currentPendingArt.imageUrl === imageUrl) {
                    currentPendingArt.aspectRatio = 1.5; // Default landscape ratio
                    updateSizePreview();
                }
            };
            img.src = imageUrl;
            
            updateSizePreview();
            dialog.classList.add('active');
            
            // Focus on title input
            setTimeout(() => {
                document.getElementById('title-input').focus();
            }, 100);
            
            // Clear the URL input
            document.getElementById('image-url-input').value = '';
        }
        
        function setupEventListeners() {
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            renderer.domElement.addEventListener('click', onCanvasClick);
            
            window.addEventListener('resize', onWindowResize);
            
            document.getElementById('toggle-ui').addEventListener('click', () => {
                document.getElementById('ui-overlay').classList.toggle('hidden');
            });
            
            document.getElementById('vr-button').addEventListener('click', toggleVR);
            
            document.getElementById('height-input').addEventListener('input', updateSizePreview);
            
            document.getElementById('viewer-close').addEventListener('click', closeArtViewer);
            document.getElementById('art-viewer').addEventListener('click', (e) => {
                if (e.target === document.getElementById('art-viewer')) {
                    closeArtViewer();
                }
            });
        }
        
        function handleFileSelect(event) {
            handleFiles(event.target.files);
        }
        
        function handleFiles(files) {
            for (let file of files) {
                const extension = file.name.split('.').pop().toLowerCase();
                
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            showPlacementDialog(file, 'image', img.width / img.height, e.target.result);
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                } else if (['obj', 'gltf', 'glb', 'fbx', 'stl'].includes(extension)) {
                    showPlacementDialog(file, '3d');
                }
            }
        }
        
        function showPlacementDialog(file, type, aspectRatio = null, imageUrl = null) {
            currentPendingArt = { file, type, aspectRatio, imageUrl };
            const dialog = document.getElementById('placement-dialog');
            const fileName = typeof file === 'string' ? file : (file.name || 'Untitled');
            document.getElementById('artwork-name').textContent = `Artwork: ${fileName}`;
            
            const imagePreview = document.getElementById('image-preview');
            if (imageUrl && type === 'image') {
                document.getElementById('preview-img').src = imageUrl;
                imagePreview.style.display = 'block';
            } else {
                imagePreview.style.display = 'none';
            }
            
            document.getElementById('dimension-label').textContent = 'Height (inches):';
            
            const locationGrid = document.getElementById('location-grid');
            locationGrid.innerHTML = '';
            selectedLocation = null;
            
            const positions = WALL_POSITIONS;
            const spots = wallSpots;
            
            positions.forEach(pos => {
                const spot = spots.find(s => s.userData.id === pos.id);
                const locationOption = document.createElement('div');
                locationOption.className = 'location-option';
                locationOption.dataset.id = pos.id;
                
                if (spot && spot.userData.occupied) {
                    locationOption.classList.add('occupied');
                }
                
                locationOption.innerHTML = `
                    <div class="location-name">${pos.displayName}</div>
                    <div class="location-status">${spot && spot.userData.occupied ? 'Occupied' : 'Available'}</div>
                `;
                
                if (!spot || !spot.userData.occupied) {
                    locationOption.addEventListener('click', () => {
                        document.querySelectorAll('.location-option').forEach(opt => 
                            opt.classList.remove('selected'));
                        locationOption.classList.add('selected');
                        selectedLocation = pos.id;
                        updateSizePreview();
                    });
                }
                
                locationGrid.appendChild(locationOption);
            });
            
            const firstAvailable = positions.find(p => 
                !spots.find(s => s.userData.id === p.id).userData.occupied);
            if (firstAvailable) {
                selectedLocation = firstAvailable.id;
                locationGrid.querySelector(`[data-id="${firstAvailable.id}"]`).classList.add('selected');
            }
            
            document.getElementById('title-input').value = '';
            document.getElementById('artist-input').value = '';
            document.getElementById('description-input').value = '';
            
            updateSizePreview();
            dialog.classList.add('active');
        }
        
        function updateSizePreview() {
            if (!currentPendingArt || !selectedLocation) return;
            
            const heightFeet = parseFloat(document.getElementById('height-input').value) || 3;
            const heightMeters = heightFeet * 0.3048;
            
            const sizePreview = document.getElementById('size-preview');
            const warning = document.getElementById('size-warning');
            
            if (currentPendingArt.type === 'image') {
                // Use aspect ratio if available, otherwise use default estimate
                const aspectRatio = currentPendingArt.aspectRatio || 1.5;
                const widthMeters = heightMeters * aspectRatio;
                const widthFeet = widthMeters / 0.3048;
                
                const estimateText = currentPendingArt.aspectRatio ? '' : ' (estimated)';
                sizePreview.textContent = `Dimensions: ${heightFeet.toFixed(1)}' × ${widthFeet.toFixed(1)}'${estimateText}`;
                
                warning.style.color = '#fbbf24';
                warning.style.background = 'rgba(251, 191, 36, 0.1)';
                
                const spot = WALL_POSITIONS.find(p => p.id === selectedLocation);
                
                if (spot) {
                    const wallLengthFeet = spot.wallLength / 0.3048;
                    
                    if (widthMeters > spot.wallLength) {
                        warning.textContent = `Artwork may exceed wall length (wall is ${wallLengthFeet.toFixed(1)}' ${spot.wall === 'back' ? 'wide' : 'long'})`;
                        warning.style.display = 'block';
                    } else {
                        warning.style.display = 'none';
                    }
                } else {
                    warning.style.display = 'none';
                }
            }
        }
        
        function cancelPlacement() {
            document.getElementById('placement-dialog').classList.remove('active');
            currentPendingArt = null;
            selectedLocation = null;
        }
        
        function placeArtwork() {
            console.log('=== PLACE ARTWORK CALLED ===');
            console.log('Current pending art:', currentPendingArt);
            console.log('Selected location:', selectedLocation);
            
            if (!currentPendingArt || !selectedLocation) {
                console.log('Missing pending art or location, returning');
                return;
            }
            
            // Validate required fields
            const title = document.getElementById('title-input').value.trim();
            const artist = document.getElementById('artist-input').value.trim();
            
            if (!title) {
                alert('Please enter a title for the artwork');
                document.getElementById('title-input').focus();
                return;
            }
            
            if (!artist) {
                alert('Please enter an artist name');
                document.getElementById('artist-input').focus();
                return;
            }
            
            const heightInches = parseFloat(document.getElementById('height-input').value);
            const heightMeters = heightInches * 0.0254;
            const heightFeet = heightInches / 12;
            
            console.log('Height - inches:', heightInches, 'meters:', heightMeters, 'feet:', heightFeet);
            
            const metadata = {
                title: title,
                artist: artist,
                description: document.getElementById('description-input').value || ''
            };
            
            console.log('Metadata:', metadata);
            console.log('Art type:', currentPendingArt.type);
            
            if (currentPendingArt.type === 'image') {
                console.log('Loading image artwork...');
                // Use aspect ratio if available, otherwise use default
                const aspectRatio = currentPendingArt.aspectRatio || 1.5;
                const artData = {
                    imageUrl: currentPendingArt.imageUrl,
                    aspectRatio: aspectRatio
                };
                const fileName = title; // Use title as filename
                loadImageArtwork(artData, selectedLocation, heightMeters, metadata, heightFeet, fileName);
            }
            
            document.getElementById('placement-dialog').classList.remove('active');
            currentPendingArt = null;
            selectedLocation = null;
        }
        
        function mapLocationNameToId(locationName) {
            if (!locationName) return null;
            return LOCATION_NAME_TO_ID_MAP[locationName] || null;
        }
        
        function mapLocationIdToName(locationId) {
            if (!locationId) return null;
            return LOCATION_ID_TO_NAME_MAP[locationId] || null;
        }
        
        function loadImageArtwork(artData, locationId, height, metadata, heightFeet, fileName) {
            console.log('=== LOAD IMAGE ARTWORK ===');
            console.log('Location ID:', locationId);
            console.log('Height (feet):', heightFeet);
            console.log('Metadata:', metadata);
            console.log('Is Admin?:', isAdmin);
            
            const wallSpot = wallSpots.find(s => s.userData.id === locationId);
            if (wallSpot && !wallSpot.userData.occupied) {
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(artData.imageUrl, async (texture) => {
                    const width = height * artData.aspectRatio;
                    
                    let airtableId = null;
                    if (isAdmin) {
                        console.log('Admin mode - saving to Airtable...');
                        // Send to Airtable
                        const locationName = mapLocationIdToName(locationId);
                        console.log('Mapped location name:', locationName);

                        airtableId = await createArtworkInAirtable({
                            title: metadata.title,
                            artist: metadata.artist,
                            description: metadata.description,
                            heightFeet: heightFeet,
                            aspectRatio: artData.aspectRatio,
                            type: 'Image',
                            locationId: locationId,
                            locationName: locationName,
                            imageUrl: artData.imageUrl,
                            originalFileName: fileName
                        });
                        
                        console.log('Returned Airtable ID:', airtableId);
                    } else {
                        console.log('Public mode - not saving to Airtable');
                    }
                    
                    createArtworkMesh(texture, fileName, wallSpot, 
                        { width, height }, metadata, artData.imageUrl, airtableId);
                    updateArtQueue(fileName, artData.imageUrl, 'Placed on wall');
                });
            } else {
                console.log('Wall spot not available:', wallSpot);
            }
        }
        
        function createArtworkMesh(texture, name, spot, dimensions, metadata, imageUrl, airtableId = null) {
            const width = dimensions.width;
            const height = dimensions.height;
            
            const frameGeometry = new THREE.BoxGeometry(width + 0.1, height + 0.1, 0.05);
            const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x8b7355, roughness: 0.8, metalness: 0.2 });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.castShadow = true;
            
            const artGeometry = new THREE.PlaneGeometry(width, height);
            const artMaterial = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.3, metalness: 0.1 });
            const art = new THREE.Mesh(artGeometry, artMaterial);
            art.position.z = 0.026;
            
            const artworkGroup = new THREE.Group();
            artworkGroup.add(frame);
            artworkGroup.add(art);
            artworkGroup.name = 'artwork';
            artworkGroup.userData = { 
                name: name, 
                spotId: spot.userData.id,
                width: width,
                metadata: metadata,
                imageUrl: imageUrl,
                airtableId: airtableId
            };
            
            artworkGroup.position.copy(spot.position);
            artworkGroup.rotation.y = spot.userData.rotation;
            
            const normal = new THREE.Vector3(0, 0, 1);
            normal.applyEuler(new THREE.Euler(0, spot.userData.rotation, 0));
            artworkGroup.position.add(normal.multiplyScalar(0.05));
            
            artworks.push(artworkGroup);
            scene.add(artworkGroup);
            
            const placard = createPlacard(metadata, spot.position, spot.userData.rotation, false, width, height);
            if (placard) {
                artworkGroup.userData.placardIndex = placards.indexOf(placard);
            }
            
            spot.userData.occupied = true;
            spot.userData.currentWidth = width;
            spot.material.color.setHex(0xff6b6b);
            spot.material.emissive.setHex(0xff6b6b);
            
            updateSpotCounters();
        }
        
        function load3DModel(file, locationId, size, metadata) {
            const reader = new FileReader();
            const extension = file.name.split('.').pop().toLowerCase();
            
            reader.onload = (e) => {
                const floorSpot = floorSpots.find(s => s.userData.id === locationId);
                if (!floorSpot || floorSpot.userData.occupied) return;
                
                const arrayBuffer = e.target.result;
                let loader;
                
                switch(extension) {
                    case 'obj':
                        loader = new THREE.OBJLoader();
                        const contents = new TextDecoder().decode(arrayBuffer);
                        const object = loader.parse(contents);
                        process3DModel(object, file.name, floorSpot, size, metadata);
                        break;
                    case 'gltf':
                    case 'glb':
                        loader = new THREE.GLTFLoader();
                        loader.parse(arrayBuffer, '', (gltf) => {
                            process3DModel(gltf.scene, file.name, floorSpot, size, metadata);
                        });
                        break;
                    case 'fbx':
                        loader = new THREE.FBXLoader();
                        const fbxObject = loader.parse(arrayBuffer);
                        process3DModel(fbxObject, file.name, floorSpot, size, metadata);
                        break;
                    case 'stl':
                        loader = new THREE.STLLoader();
                        const geometry = loader.parse(arrayBuffer);
                        const material = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.5, metalness: 0.3 });
                        const mesh = new THREE.Mesh(geometry, material);
                        process3DModel(mesh, file.name, floorSpot, size, metadata);
                        break;
                }
                
                updateArtQueue(file.name, null, 'Placed as 3D sculpture');
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        function process3DModel(object, name, spot, size, metadata) {
            const pedestal = createPedestal(spot.position, spot.userData.type);
            spot.userData.pedestal = pedestal;
            
            const box = new THREE.Box3().setFromObject(object);
            const boxSize = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            
            const maxDimension = Math.max(boxSize.x, boxSize.y, boxSize.z);
            const scale = size / maxDimension;
            object.scale.multiplyScalar(scale);
            
            object.position.sub(center.multiplyScalar(scale));
            
            const modelGroup = new THREE.Group();
            modelGroup.add(object);
            modelGroup.name = '3d-model';
            modelGroup.userData = { 
                name: name, 
                spotId: spot.userData.id,
                metadata: metadata
            };
            
            modelGroup.position.copy(spot.position);
            modelGroup.position.y = 0.85;
            
            artworks.push(modelGroup);
            scene.add(modelGroup);
            
            const placard = createPlacard(metadata, spot.position, 0, true);
            if (placard) {
                modelGroup.userData.placardIndex = placards.indexOf(placard);
            }
            
            spot.userData.occupied = true;
            spot.material.color.setHex(0xff6b6b);
            spot.material.emissive.setHex(0xff6b6b);
            
            object.traverse((child) => {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    if (!child.material) {
                        child.material = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.5, metalness: 0.3 });
                    }
                }
            });
            
            updateSpotCounters();
        }
        
        function updateArtQueue(name, dataUrl, status) {
            const queueDiv = document.getElementById('art-queue');
            const artItem = document.createElement('div');
            artItem.className = 'art-item';
            
            if (dataUrl) {
                artItem.innerHTML = `
                    <img src="${dataUrl}" class="art-thumb">
                    <div class="art-info">
                        <div>${name}</div>
                        <div class="art-status">${status}</div>
                    </div>
                `;
            } else {
                artItem.innerHTML = `
                    <div style="width: 40px; height: 40px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 4px; margin-right: 10px; display: flex; align-items: center; justify-content: center; color: white;">3D</div>
                    <div class="art-info">
                        <div>${name}</div>
                        <div class="art-status">${status}</div>
                    </div>
                `;
            }
            
            queueDiv.appendChild(artItem);
            
            // Show sync status
            if (isAdmin && status.includes('Placed')) {
                const syncStatus = document.getElementById('sync-status');
                syncStatus.textContent = '⏳ Saving to Airtable...';
                syncStatus.style.color = '#667eea';
                
                setTimeout(() => {
                    syncStatus.textContent = '✓ Saved to Airtable';
                    syncStatus.style.color = '#4ade80';
                }, 2000);
            }
        }
        
        function updateSpotCounters() {
            const wallOccupied = wallSpots.filter(s => s.userData.occupied).length;
            
            const wallElement = document.getElementById('wall-spots');
            
            wallElement.textContent = `${wallOccupied}/${wallSpots.length}`;
            wallElement.className = wallOccupied >= wallSpots.length ? 'spot-occupied' : 'spot-available';
        }
        
        function onKeyDown(event) {
            switch(event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'Tab':
                    event.preventDefault();
                    toggleViewMode();
                    break;
                case 'KeyR':
                    if (isAdmin) {
                        removeNearestArtwork();
                    }
                    break;
            }
        }
        
        function onKeyUp(event) {
            switch(event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;
            }
        }
        
        function toggleViewMode() {
            const modes = ['normal', 'spots'];
            const currentIndex = modes.indexOf(viewMode);
            viewMode = modes[(currentIndex + 1) % modes.length];
            
            wallSpots.forEach(spot => {
                spot.visible = viewMode === 'spots' && !spot.userData.occupied;
            });
            
            floorSpots.forEach(spot => {
                spot.visible = viewMode === 'spots' && !spot.userData.occupied;
            });
        }
        
        function removeNearestArtwork() {
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(artworks, true);
            
            if (intersects.length > 0) {
                let artworkGroup = intersects[0].object;
                while (artworkGroup.parent && !artworkGroup.userData.spotId) {
                    artworkGroup = artworkGroup.parent;
                }
                
                if (artworkGroup.userData.spotId) {
                    if (isAdmin && artworkGroup.userData.airtableId) {
                        deleteArtworkFromAirtable(artworkGroup.userData.airtableId);
                    }
                    
                    const wallSpot = wallSpots.find(s => s.userData.id === artworkGroup.userData.spotId);
                    const floorSpot = floorSpots.find(s => s.userData.id === artworkGroup.userData.spotId);
                    
                    if (wallSpot) {
                        wallSpot.userData.occupied = false;
                        wallSpot.userData.currentWidth = 0;
                        wallSpot.material.color.setHex(0x667eea);
                        wallSpot.material.emissive.setHex(0x667eea);
                    }
                    
                    if (floorSpot) {
                        floorSpot.userData.occupied = false;
                        floorSpot.material.color.setHex(0x667eea);
                        floorSpot.material.emissive.setHex(0x667eea);
                        
                        if (floorSpot.userData.pedestal) {
                            scene.remove(floorSpot.userData.pedestal);
                            floorSpot.userData.pedestal = null;
                        }
                    }
                    
                    if (artworkGroup.userData.placardIndex !== undefined && 
                        placards[artworkGroup.userData.placardIndex]) {
                        scene.remove(placards[artworkGroup.userData.placardIndex]);
                        placards[artworkGroup.userData.placardIndex] = null;
                    }
                    
                    scene.remove(artworkGroup);
                    const index = artworks.indexOf(artworkGroup);
                    if (index > -1) artworks.splice(index, 1);
                    
                    updateSpotCounters();
                }
            }
        }
        
        function onCanvasClick(event) {
            if (!document.pointerLockElement) return;
            
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            const artIntersects = raycaster.intersectObjects(artworks, true);
            if (artIntersects.length > 0) {
                let artworkGroup = artIntersects[0].object;
                while (artworkGroup.parent && !artworkGroup.userData.metadata) {
                    artworkGroup = artworkGroup.parent;
                }
                
                if (artworkGroup.userData.metadata) {
                    if (isAdmin && artworkGroup.userData.imageUrl) {
                        showEditDialog(artworkGroup);
                    } else if (artworkGroup.userData.imageUrl) {
                        showArtViewer(artworkGroup.userData);
                    }
                }
            }
        }
        
        function showEditDialog(artworkGroup) {
            currentEditingArtwork = artworkGroup;
            const dialog = document.getElementById('edit-dialog');
            
            document.getElementById('edit-artwork-name').textContent = artworkGroup.userData.name;
            document.getElementById('edit-title-input').value = artworkGroup.userData.metadata.title || '';
            document.getElementById('edit-artist-input').value = artworkGroup.userData.metadata.artist || '';
            document.getElementById('edit-description-input').value = artworkGroup.userData.metadata.description || '';
            
            const heightMeters = artworkGroup.userData.width / (artworkGroup.userData.imageUrl ? 
                (artworkGroup.children[1].geometry.parameters.width / artworkGroup.children[1].geometry.parameters.height) : 1);
            const heightInches = heightMeters / 0.0254;
            document.getElementById('edit-height-input').value = heightInches.toFixed(0);
            
            const imagePreview = document.getElementById('edit-image-preview');
            if (artworkGroup.userData.imageUrl) {
                document.getElementById('edit-preview-img').src = artworkGroup.userData.imageUrl;
                imagePreview.style.display = 'block';
            } else {
                imagePreview.style.display = 'none';
            }
            
            dialog.classList.add('active');
            document.exitPointerLock();
        }
        
        async function saveArtworkEdit() {
            if (!currentEditingArtwork) return;
            
            const newMetadata = {
                title: document.getElementById('edit-title-input').value || '',
                artist: document.getElementById('edit-artist-input').value || '',
                description: document.getElementById('edit-description-input').value || ''
            };
            
            const heightInches = parseFloat(document.getElementById('edit-height-input').value);
            const heightFeet = heightInches / 12;
            
            if (currentEditingArtwork.userData.airtableId) {
                await updateArtworkInAirtable({
                    id: currentEditingArtwork.userData.airtableId,
                    title: newMetadata.title,
                    artist: newMetadata.artist,
                    description: newMetadata.description,
                    heightFeet: heightFeet
                });
            }
            
            currentEditingArtwork.userData.metadata = newMetadata;
            
            if (currentEditingArtwork.userData.placardIndex !== undefined && 
                placards[currentEditingArtwork.userData.placardIndex]) {
                const oldPlacard = placards[currentEditingArtwork.userData.placardIndex];
                scene.remove(oldPlacard);
                
                const spot = wallSpots.find(s => s.userData.id === currentEditingArtwork.userData.spotId);
                if (spot) {
                    const artworkWidth = currentEditingArtwork.userData.width;
                    const artworkHeight = currentEditingArtwork.children[1].geometry.parameters.height;
                    const newPlacard = createPlacard(newMetadata, spot.position, spot.userData.rotation, false, artworkWidth, artworkHeight);
                    if (newPlacard) {
                        placards[currentEditingArtwork.userData.placardIndex] = newPlacard;
                    }
                }
            }
            
            cancelEdit();
        }
        
        function cancelEdit() {
            document.getElementById('edit-dialog').classList.remove('active');
            currentEditingArtwork = null;
        }
        
        function showArtViewer(artData) {
            const viewer = document.getElementById('art-viewer');
            const image = document.getElementById('viewer-image');
            
            image.src = artData.imageUrl;
            document.getElementById('viewer-title').textContent = artData.metadata.title || 'Untitled';
            document.getElementById('viewer-artist').textContent = artData.metadata.artist || '';
            document.getElementById('viewer-description').textContent = artData.metadata.description || '';
            
            viewer.classList.add('active');
            currentZoom = 1;
            image.style.transform = 'scale(1)';
            
            document.exitPointerLock();
        }
        
        function closeArtViewer() {
            document.getElementById('art-viewer').classList.remove('active');
        }
        
        function zoomIn() {
            currentZoom = Math.min(currentZoom + 0.25, 3);
            document.getElementById('viewer-image').style.transform = `scale(${currentZoom})`;
        }
        
        function zoomOut() {
            currentZoom = Math.max(currentZoom - 0.25, 0.5);
            document.getElementById('viewer-image').style.transform = `scale(${currentZoom})`;
        }
        
        function resetZoom() {
            currentZoom = 1;
            document.getElementById('viewer-image').style.transform = 'scale(1)';
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function checkVRSupport() {
            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                    const vrButton = document.getElementById('vr-button');
                    if (supported) {
                        vrButton.disabled = false;
                        vrButton.textContent = 'Enter VR Mode';
                    } else {
                        vrButton.textContent = 'VR Not Supported';
                    }
                });
            }
        }
        
        async function toggleVR() {
            const vrButton = document.getElementById('vr-button');
            
            if (!vrSession) {
                try {
                    vrSession = await navigator.xr.requestSession('immersive-vr', {
                        optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking']
                    });
                    
                    renderer.xr.setSession(vrSession);
                    vrButton.textContent = 'Exit VR Mode';
                    
                    vrSession.addEventListener('end', () => {
                        vrSession = null;
                        vrButton.textContent = 'Enter VR Mode';
                    });
                } catch (error) {
                    console.error('Failed to start VR session:', error);
                }
            } else {
                vrSession.end();
            }
        }
        
        function updateMovement(delta) {
            if (!document.pointerLockElement && !vrSession) return;
            
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            
            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();
            
            if (moveForward || moveBackward) {
                velocity.z -= direction.z * 15.0 * delta;
            }
            if (moveLeft || moveRight) {
                velocity.x -= direction.x * 15.0 * delta;
            }
            
            const forward = new THREE.Vector3();
            const right = new THREE.Vector3();
            
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();
            
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
            
            camera.position.add(forward.multiplyScalar(-velocity.z * delta));
            camera.position.add(right.multiplyScalar(-velocity.x * delta));
            
            camera.position.x = Math.max(-7, Math.min(7, camera.position.x));
            camera.position.z = Math.max(-9, Math.min(9, camera.position.z));
        }
        
        let clock = new THREE.Clock();
        
        function animate() {
            const delta = clock.getDelta();
            
            updateMovement(delta);
            
            artworks.forEach(artwork => {
                if (artwork.name === '3d-model') {
                    artwork.rotation.y += delta * 0.1;
                }
            });
            
            renderer.render(scene, camera);
            
            if (vrSession) {
                renderer.setAnimationLoop(() => {
                    renderer.render(scene, camera);
                });
            } else {
                requestAnimationFrame(animate);
            }
        }
        
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                escapeCount++;
                
                if (escapeTimer) {
                    clearTimeout(escapeTimer);
                }
                
                if (escapeCount >= 3 && !isAdmin) {
                    document.getElementById('admin-auth').classList.add('active');
                    setTimeout(() => {
                        document.getElementById('admin-password').focus();
                    }, 100);
                    escapeCount = 0;
                } else {
                    escapeTimer = setTimeout(() => {
                        escapeCount = 0;
                    }, 1000);
                }
            }
        });
        
        window.addEventListener('load', init);
    </script>
</body>
</html>
